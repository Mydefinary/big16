01 Kubernetes 성능 최적화 멘토링 가이드

# 시나리오: webtoon-dashboard-backend 서비스 성능 개선

## 시니어 개발자의 문제 해결 접근법

### 1단계: 현황 파악 및 문제 정의
- 문제: 서비스 초기 로딩이 너무 느림 (사용자 불만)
- 목표: 성능이 좋은 ragpool 노드풀(Standard_D4s_v3)로 이동
- 현재 상태: userpool 노드에서 실행 중

**시니어의 접근법:**
- 단순히 nodeSelector만 변경하는 것이 아니라, 전체 성능 최적화 관점에서 접근
- 노드 이동 후에도 리소스 활용도를 체크하여 추가 최적화 수행

### 2단계: 체계적인 분석
```bash
# 현재 팟 상태 확인
kubectl get pods -n lee -o wide | grep webtoon-dashboard-backend

# 노드 정보 확인 
kubectl describe node aks-ragpool-19660956-vmss000000

# 리소스 사용량 모니터링
kubectl top pods -n lee
```

**배운 점:** 
- 문제 해결 전에 항상 현재 상태를 정확히 파악해야 함
- 단일 지표가 아닌 종합적인 분석이 필요

### 3단계: 점진적 최적화

#### 3.1 첫 번째 최적화 (nodeSelector 변경)
```yaml
nodeSelector:
  agentpool: ragpool  # userpool → ragpool
```
- 결과: 1초 성능 향상 (좋은 시작!)

#### 3.2 두 번째 최적화 (리소스 할당 개선)
**문제 발견:** 4 vCPU, 16GB RAM 노드에서 0.5 CPU, 512Mi만 사용 (12.5% 활용률)

```yaml
# 기존 설정 (너무 보수적)
resources:
  requests:
    cpu: 100m
    memory: 256Mi
  limits:
    cpu: 500m
    memory: 512Mi
replicas: 1

# 1차 개선
resources:
  requests:
    cpu: 200m
    memory: 512Mi  
  limits:
    cpu: 1000m
    memory: 1Gi
replicas: 2

# 최종 최적화 (공격적 할당)
resources:
  requests:
    cpu: 500m      # 팟당 0.5코어 보장
    memory: 1Gi    # 팟당 1GB 보장
  limits:
    cpu: 1500m     # 팟당 최대 1.5코어
    memory: 3Gi    # 팟당 최대 3GB
replicas: 2
```

## 주니어 개발자가 배워야 할 핵심 개념

### 1. 리소스 관리의 핵심
- **Requests**: 노드 스케줄링의 기준 (보장되는 최소 리소스)
- **Limits**: 팟이 사용할 수 있는 최대 리소스 (버스트 시)
- **적절한 비율**: requests는 실제 사용량 기준, limits는 피크 시를 고려

### 2. 성능 최적화 원칙
- **측정 → 분석 → 개선 → 재측정** 사이클 반복
- 단일 해결책이 아닌 다각도 접근
- 보수적 시작 → 점진적 개선

### 3. 노드풀 활용 전략
```bash
# 노드 리소스 현황 확인 방법
kubectl describe node [NODE_NAME] | grep -A 10 "Allocated resources"

# 실제 사용량 vs 할당량 비교
kubectl top nodes
kubectl top pods -n [NAMESPACE]
```

## 부족했던 점과 개선 방향

### 주니어의 일반적인 실수
1. **과도한 보수적 설정**
   - 문제: 노드 성능의 12.5%만 사용
   - 개선: 실제 워크로드에 맞는 적극적 할당

2. **단일 복제본 사용**
   - 문제: 단일 장애점, 로드 분산 불가
   - 개선: 최소 2개 이상 복제본으로 가용성 확보

3. **모니터링 부족**
   - 문제: 변경 후 실제 효과 검증 안 함
   - 개선: 지속적인 모니터링과 측정

### 발전 방향

#### 1. 기술적 역량 강화
```bash
# 필수 명령어 숙달
kubectl top pods/nodes
kubectl describe pod/node
kubectl get events
kubectl logs -f [POD_NAME]
```

#### 2. 성능 튜닝 방법론
- **HPA (Horizontal Pod Autoscaler)** 도입 검토
- **VPA (Vertical Pod Autoscaler)** 활용
- **Resource Quotas** 이해

#### 3. 모니터링 도구 활용
- Prometheus + Grafana
- kubectl top 명령어 활용
- 로그 분석 능력

## 실무 팁과 주의사항

### DO (해야 할 것)
✅ 변경 전 현재 상태 백업
✅ 점진적 변경 (replicas 1→2, resources 단계적 증가)
✅ 변경 후 모니터링 (최소 30분)
✅ 다른 서비스에 미치는 영향 확인

### DON'T (하지 말아야 할 것)  
❌ 한 번에 모든 설정 변경
❌ 프로덕션에서 바로 테스트
❌ 노드 리소스 한계 무시
❌ 다른 팟들의 리소스 사용량 미확인

### 리소스 할당 가이드라인
```yaml
# 웹 애플리케이션 기본 설정
requests:
  cpu: 100-200m
  memory: 256-512Mi
limits:
  cpu: 500-1000m
  memory: 512Mi-1Gi

# 데이터 처리 애플리케이션 (TF-IDF 분석 등)
requests:
  cpu: 500m-1000m
  memory: 1-2Gi  
limits:
  cpu: 1000-2000m
  memory: 2-4Gi
```

## 성과 측정 지표

### 정량적 지표
- API 응답 시간: 159ms (매우 우수)
- 초기 로딩 시간: 1초 단축 → 추가 개선 예상
- 리소스 활용률: 12.5% → 75% (6배 향상)
- 가용성: 단일 팟 → 2개 팟 (무중단 서비스)

### 정성적 지표  
- 사용자 경험 개선
- 시스템 안정성 향상
- 확장성 확보
- 장애 대응력 강화

## 다음 단계 로드맵

### 단기 (1-2주)
1. 현재 설정 모니터링 및 미세 조정
2. 다른 backend 서비스들 동일한 방식으로 최적화
3. 로드 테스트를 통한 성능 검증

### 중기 (1-2개월)
1. HPA 설정으로 자동 스케일링 구현
2. 리소스 모니터링 대시보드 구축
3. 성능 기준선(baseline) 설정

### 장기 (3-6개월)
1. 클러스터 전체 리소스 최적화
2. 비용 효율성 분석 및 개선
3. 자동화된 성능 튜닝 도구 도입

---

## 멘토링 마무리

이번 작업을 통해 배운 가장 중요한 교훈:
**"좋은 인프라가 있어도 제대로 활용하지 못하면 의미가 없다"**

성능 최적화는 단순한 설정 변경이 아니라, 전체 시스템을 이해하고 
지속적으로 모니터링하며 개선해 나가는 과정입니다.

앞으로는 변경 사항이 있을 때마다:
1. 현재 상태 측정
2. 목표 설정  
3. 점진적 개선
4. 결과 검증
5. 문서화

이 5단계를 습관화하시기 바랍니다.